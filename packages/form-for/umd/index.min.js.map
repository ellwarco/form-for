{"version":3,"file":"index.min.js","sources":["../src/cloneObject.js","../src/prefixer.js","../src/FieldGroup.js","../src/BaseForm.js","../src/Form.js","../src/Field.js","../src/fieldDecorator.js"],"sourcesContent":["// @flow\n\nexport default function cloneObject(object: Object, ...sources: Object[]): Object {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object, ...sources);\n}\n","export default function prefixer(...prefixes: (?string)[]) {\n  return prefixes\n    .filter(prefix => prefix || prefix === 0)\n    .map((prefix: string, index: number) => (index === 0 ? prefix : `[${prefix}]`))\n    .join('');\n}\n","// @flow\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport type { Schema } from './BaseForm';\nimport cloneObject from './cloneObject';\nimport prefixer from './prefixer';\n\nexport type Props = {\n  for: Object,\n  schema?: Schema,\n  prefix?: string,\n  index?: any,\n  children: React.Node\n};\n\nexport default class FieldGroup extends React.Component<Props> {\n  static contextTypes = {\n    onChange: PropTypes.func.isRequired,\n    name: PropTypes.string\n  };\n\n  static childContextTypes = {\n    object: PropTypes.object,\n    schema: PropTypes.object,\n    prefix: PropTypes.string,\n    onChange: PropTypes.func\n  };\n\n  /*\n   * Getters\n   */\n\n  getChildContext() {\n    return {\n      object: this.props.for,\n      schema: this.getSchema(),\n      prefix: this.getPrefix(),\n      onChange: this.handleChange\n    };\n  }\n\n  getPrefix(): string {\n    return prefixer(this.context.prefix, this.context.name, this.props.prefix, this.props.index);\n  }\n\n  getSchema(): Schema {\n    return this.props.schema || this.props.for.schema || this.throwUndefinedSchema();\n  }\n\n  getNewObjectFor(name: string, value: any, index: ?any) {\n    if (typeof index === 'undefined') return cloneObject(this.props.for, { [name]: value });\n\n    const previousValue = this.props.for[name];\n    let newValue;\n\n    if (Array.isArray(previousValue)) {\n      newValue = [...previousValue];\n      newValue[index] = value;\n    } else {\n      // $FlowFixMe\n      newValue = cloneObject(previousValue, { [index]: value });\n    }\n\n    return cloneObject(this.props.for, { [name]: newValue });\n  }\n\n  /*\n   * Dispatchers\n   */\n\n  dispatchChange(newObject: Object) {\n    this.context.name ? this.dispatchNestedChange(newObject) : this.dispatchFormChange(newObject);\n  }\n\n  dispatchNestedChange(newObject: Object) {\n    this.context.onChange(this.context.name, newObject, this.props.index);\n  }\n\n  dispatchFormChange(newObject: Object) {\n    this.context.onChange(newObject);\n  }\n\n  /*\n   * Handlers\n   */\n\n  onChange(name: string, value: any, index?: any) {\n    const newObject = this.getNewObjectFor(name, value, index);\n    this.dispatchChange(newObject);\n  }\n\n  handleChange = (name: string, value: any, index?: any) => {\n    this.onChange(name, value, index);\n  };\n\n  /*\n   * Lifecycle\n   */\n\n  render(): React.Node {\n    return this.props.children || null;\n  }\n\n  /*\n   * Errors\n   */\n\n  throwUndefinedSchema(): any {\n    const constructor = this.props.for.constructor.name;\n    throw new Error(`Undefined schema for \"${constructor}\" instance`);\n  }\n}\n","// @flow\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport FieldGroup from './FieldGroup';\n\nexport type SchemaProperty = {\n  type?: string,\n  [key: string]: any\n};\n\nexport type Schema = {\n  [key: string]: SchemaProperty\n};\n\nexport type Props = {\n  for?: Object,\n  schema?: Schema,\n  children: React.Node,\n  onSubmit?: (event: SyntheticEvent<HTMLFormElement>, data: Object, valid?: boolean) => any,\n  onChange?: (data: Object, valid?: boolean) => any,\n  touchOnMount?: boolean,\n  noValidate?: boolean\n};\n\nexport default class BaseForm extends React.Component<Props, *> {\n  static fieldGroupComponent: React.ComponentType<*> = FieldGroup;\n\n  form: ?HTMLFormElement;\n\n  /*\n   * Getters\n   */\n  static childContextTypes = {\n    onChange: PropTypes.func,\n    touchOnMount: PropTypes.bool,\n    noValidate: PropTypes.bool\n  };\n\n  getChildContext() {\n    return {\n      onChange: this.handleChange,\n      touchOnMount: !!this.props.touchOnMount,\n      noValidate: !!this.props.noValidate\n    };\n  }\n\n  getData(): Object {\n    return this.props.for || {};\n  }\n\n  getForm(): HTMLFormElement {\n    return this.form || this.throwUndefinedForm();\n  }\n\n  /*\n   * Handlers\n   */\n\n  onChange(data: Object) {\n    const onChange = this.props.onChange;\n    if (onChange) onChange(this.getData());\n  }\n\n  /**\n   * Since onChange is used by classes that extend BaseForm, handleChange exists to do .bind()\n   */\n  handleChange = (value: Object) => {\n    this.onChange(value);\n  };\n\n  handleSubmit = (event: SyntheticEvent<HTMLFormElement>) => {\n    const onSubmit = this.props.onSubmit;\n    if (onSubmit) onSubmit(event, this.getData());\n  };\n\n  /*\n   * Lifecycle\n   */\n\n  render(): React.Node {\n    const { ['for']: object, schema, children, ...formProps } = {\n      ...this.props\n    };\n    delete formProps.onChange; // Prevent the browser onChange event to be called\n    delete formProps.touchOnMount;\n\n    let content;\n    if (!object) {\n      content = children;\n    } else {\n      content = React.createElement(this.constructor.fieldGroupComponent, {\n        for: this.getData(),\n        schema,\n        children\n      });\n    }\n\n    return (\n      <form {...formProps} ref={el => (this.form = el)} onSubmit={this.handleSubmit}>\n        {content}\n      </form>\n    );\n  }\n\n  /*\n   * Errors\n   */\n\n  throwUndefinedForm(): any {\n    throw new Error('Undefined form HTML element');\n  }\n}\n","// @flow\n\nimport * as React from 'react';\nimport BaseForm from './BaseForm';\n\n/*\n * setState(...) only keeps enumerable properties, which causes `schema` created using @field to disappear\n * To work around that it's used the `data` and setState({})\n */\nexport default class Form extends BaseForm {\n  data: Object;\n\n  constructor(props: any) {\n    super(props);\n    this.data = props.for || {};\n  }\n\n  getData() {\n    return this.data;\n  }\n\n  onChange(data: Object) {\n    this.data = data;\n    this.setState({});\n    super.onChange(data);\n  }\n}\n","// @flow\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\n\nimport type { SchemaProperty } from './BaseForm';\nimport prefixer from './prefixer';\n\nexport type Props = {\n  name: string,\n  type?: string,\n  error?: string,\n  onFocus?: Function,\n  onChange?: Function\n};\n\nexport type ComponentProps = {\n  name: string,\n  type?: string,\n  error?: string,\n  touched: boolean,\n  value: any,\n  onMount: Function,\n  onFocus: Function,\n  onChange: Function\n};\n\nexport default class Field extends React.Component<Props> {\n  target: Object;\n  touched: ?boolean;\n  incomingError: ?string;\n  memoizedError: ?string;\n\n  /*\n   * Component binding\n   */\n\n  static connectedComponents: { [_: string]: React.ComponentType<*> } = {};\n\n  static connect(type: string, component: React.ComponentType<*>): void {\n    Field.connectedComponents[type] = component;\n  }\n\n  /*\n   * Context\n   */\n\n  static contextTypes = {\n    object: PropTypes.object.isRequired,\n    schema: PropTypes.object.isRequired,\n    prefix: PropTypes.string,\n    onChange: PropTypes.func.isRequired,\n    touchOnMount: PropTypes.bool.isRequired,\n    noValidate: PropTypes.bool.isRequired\n  };\n\n  static childContextTypes = {\n    name: PropTypes.string\n  };\n\n  getChildContext() {\n    return {\n      name: this.props.name\n    };\n  }\n\n  /*\n   * Getters\n   */\n\n  getContextObject() {\n    return this.context.object;\n  }\n\n  getContextObjectValue() {\n    return this.getContextObject()[this.props.name];\n  }\n\n  getSchemaProperty(): SchemaProperty {\n    const property = this.context.schema[this.props.name];\n    if (!property) this.warnMissingSchemaProperty();\n\n    return property || {};\n  }\n\n  getType(): string {\n    return this.props.type || this.getSchemaProperty().type || 'text';\n  }\n\n  getPrefixedName() {\n    return prefixer(this.context.prefix, this.props.name);\n  }\n\n  getComponent(): React.ComponentType<*> {\n    return Field.connectedComponents[this.getType()] || this.throwMissingTypeConnection();\n  }\n\n  getValue(incomingValue?: any) {\n    return typeof incomingValue !== 'undefined' ? incomingValue : this.getTargetValue();\n  }\n\n  getTargetValue(): any {\n    if (this.target.type === 'checkbox') return this.target.checked;\n    return this.target.value;\n  }\n\n  isTouched(): boolean {\n    return this.touched || this.context.touchOnMount;\n  }\n\n  getError(value?: any): ?any {\n    if (this.context.noValidate) return null;\n    if (this.props.error) return this.props.error;\n\n    let error = this.getSchemaProperty()['error'];\n    if (error) {\n      if (typeof error === 'string') {\n        error = this.context.object[error];\n      }\n\n      if (typeof error === 'function') {\n        return error.bind(this.context.object)(this.context.object, this.props.name);\n      }\n\n      return error;\n    }\n\n    return this.incomingError || (this.target || {}).validationMessage;\n  }\n\n  /*\n   * Setters\n   */\n\n  setValue(incomingValue: ?any) {\n    this.context.onChange(this.props.name, this.getValue(incomingValue));\n  }\n\n  setBrowserCustomValidity(message?: ?string): void {\n    if (!this.target) return;\n\n    const targets = Array.isArray(this.target) ? this.target : [this.target];\n    targets.forEach(element => {\n      if (element.setCustomValidity) element.setCustomValidity(message || '');\n    });\n  }\n\n  clearBrowserCustomValidity() {\n    this.setBrowserCustomValidity();\n  }\n\n  /*\n   * Actions\n   */\n\n  touch() {\n    this.touched = true;\n  }\n\n  touchAndRender() {\n    if (!this.isTouched()) {\n      this.touch();\n      this.forceUpdate();\n    } else {\n      this.touch();\n    }\n  }\n\n  validate(incomingError?: any): ?string {\n    this.clearBrowserCustomValidity();\n\n    this.incomingError = incomingError;\n    const error = this.getError();\n\n    this.setBrowserCustomValidity(error);\n    return error;\n  }\n\n  /*\n   * Handlers\n   */\n\n  handleMount = (target: Object) => {\n    this.target = target;\n    this.forceUpdate();\n  };\n\n  handleFocus = (event?: Event) => {\n    this.target = (event || {}).target || this.target;\n    this.touchAndRender();\n\n    if (this.props.onFocus) this.props.onFocus(event);\n  };\n\n  handleChange = (event?: Event, value?: any, error?: any) => {\n    this.target = (event || {}).target || this.target;\n    this.setValue(value);\n    this.touch();\n\n    if (this.props.onChange) this.props.onChange(event);\n  };\n\n  /*\n   * Lifecycle\n   */\n\n  render() {\n    let error = this.validate();\n    if (!error || (typeof error === 'string' && !error.length)) error = null; // Avoid changes from false, undefined, 0 and ''\n\n    return React.createElement(this.getComponent(), {\n      ...this.getSchemaProperty(),\n      ...this.props,\n      name: this.getPrefixedName(),\n      value: this.getContextObjectValue() || '',\n      error: error,\n      touched: this.isTouched(),\n      onMount: this.handleMount,\n      onFocus: this.handleFocus,\n      onChange: this.handleChange\n    });\n  }\n\n  /*\n   * Errors\n   */\n\n  warnMissingSchemaProperty() {\n    const name = this.props.name;\n    const constructor = this.context.object.constructor.name;\n    console.warn(`Undefined property \"${name}\" in schema for \"${constructor}\" instance`);\n  }\n\n  throwMissingTypeConnection() {\n    const type = this.getType();\n    const name = this.props.name;\n    const constructor = this.context.object.constructor.name;\n    throw new Error(`Missing \"${type}\" connection requested for property \"${name}\" in \"${constructor}\" instance`);\n  }\n}\n","// @flow\n\nfunction decorate(target: any, key: string, descriptor: any, properties: { [_: string]: any }) {\n  if (!target.schema) target.schema = {};\n  target.schema[key] = properties;\n  descriptor.writable = true;\n}\n\nexport default function fieldDecorator(targetOrProperties: any, key?: string, descriptor?: any) {\n  if (key) {\n    return decorate(targetOrProperties, key, descriptor, {});\n  }\n\n  return (target: any, key: string, descriptor: any) => decorate(target, key, descriptor, targetOrProperties);\n}\n"],"names":["cloneObject","object","sources","Object","assign","create","getPrototypeOf","prefixer","prefixes","filter","prefix","map","index","join","FieldGroup","handleChange","name","value","onChange","this","props","for","getSchema","getPrefix","context","schema","throwUndefinedSchema","previousValue","newValue","Array","isArray","newObject","dispatchNestedChange","dispatchFormChange","getNewObjectFor","dispatchChange","children","constructor","Error","React","contextTypes","PropTypes","func","isRequired","string","childContextTypes","BaseForm","handleSubmit","event","onSubmit","_this","getData","touchOnMount","noValidate","form","throwUndefinedForm","data","formProps","content","fieldGroupComponent","React.createElement","ref","_this2","el","bool","Form","setState","Field","handleMount","target","forceUpdate","handleFocus","touchAndRender","onFocus","error","setValue","touch","getContextObject","property","warnMissingSchemaProperty","type","getSchemaProperty","connectedComponents","getType","throwMissingTypeConnection","incomingValue","getTargetValue","checked","touched","bind","incomingError","validationMessage","getValue","message","forEach","element","setCustomValidity","setBrowserCustomValidity","isTouched","clearBrowserCustomValidity","getError","validate","length","getComponent","getPrefixedName","getContextObjectValue","warn","component","decorate","key","descriptor","properties","writable","targetOrProperties"],"mappings":"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"}